
namespace system
{

    [System.Serializable]
    public abstract class Delegate // : System.ICloneable // , System.Runtime.Serialization.ISerializable
    {

        [java.attr.RetainType] protected object _target;

        // below fields referenced by generated Invoke() methods.  do not change names
        [java.attr.RetainType] protected object invokable;
        [java.attr.RetainType] protected Delegate following;



        protected Delegate(object argTarget, object argInvokable)
        {
            ThrowHelper.ThrowIfNull(argInvokable);

            _target = argTarget;
            invokable = argInvokable;
        }



        public override bool Equals(object obj)
        {
            var d = obj as Delegate;
            return (d != null && _target == d._target && invokable == d.invokable);
        }

        public override int GetHashCode() => 1;



        public static Delegate Combine(Delegate a, Delegate b)
            => object.ReferenceEquals(a, null) ? b : a.CombineImpl(b);

        public static Delegate Remove(Delegate source, Delegate value)
            =>    object.ReferenceEquals(source, null) ? null
                : object.ReferenceEquals(value, null) ? source
                : source.RemoveImpl(value);

        protected virtual Delegate CombineImpl(Delegate d)
            => throw new System.NotSupportedException();

        protected virtual Delegate RemoveImpl(Delegate d)
            => d.Equals(this) ? null : this;



        public virtual object Clone() => MemberwiseClone();
        public object get_Target() => _target;
        public System.Reflection.MethodInfo get_Method()
            => throw new System.MemberAccessException("DelegateMethod");
    }



    [System.Serializable]
    public abstract class MulticastDelegate : Delegate
    {
        [java.attr.RetainType] protected MulticastDelegate fromDelegate;

        protected MulticastDelegate(object argTarget, object argInvokable)
            : base(argTarget, argInvokable)
        {
        }



        public override bool Equals(object obj)
        {
            if (    object.ReferenceEquals(fromDelegate, obj)
                 && (! object.ReferenceEquals(fromDelegate, null)))
            {
                return true;
            }
            return base.Equals(obj);
        }

        public override int GetHashCode() => base.GetHashCode();



        protected override sealed Delegate CombineImpl(Delegate other)
        {
            if (object.ReferenceEquals(other, null))
                return this;

            if (GetType() != other.GetType())
                throw new System.ArgumentException();

            var dlg1 = (MulticastDelegate) MemberwiseClone();
            if (object.ReferenceEquals(dlg1.fromDelegate, null))
                dlg1.fromDelegate = this;

            var dlg2 = (MulticastDelegate) other;

            if (dlg1.following == null)
            {
                var new2 = (MulticastDelegate) dlg2.MemberwiseClone();
                if (object.ReferenceEquals(new2.fromDelegate, null))
                    new2.fromDelegate = dlg2;

                dlg1.following = new2;
            }
            else
            {
                var following = (MulticastDelegate) dlg1.following;
                dlg1.following = (MulticastDelegate) following.CombineImpl(other);
            }

            return dlg1;
        }



        protected override sealed Delegate RemoveImpl(Delegate other)
        {
            var dlgToRemove = other as MulticastDelegate;
            if (object.ReferenceEquals(dlgToRemove, null))
                return this;

            var oldFollowing = (MulticastDelegate) this.following;

            if (    object.ReferenceEquals(fromDelegate, dlgToRemove)
                 || object.ReferenceEquals(fromDelegate, dlgToRemove.fromDelegate))
            {
                return oldFollowing;
            }

            if (object.ReferenceEquals(oldFollowing, null))
                return this;

            Delegate newFollowing;

            if (    object.ReferenceEquals(oldFollowing.fromDelegate, dlgToRemove)
                 || object.ReferenceEquals(oldFollowing.fromDelegate, dlgToRemove.fromDelegate))
            {
                newFollowing = oldFollowing.following;
            }
            else
            {
                newFollowing = oldFollowing.RemoveImpl(other);
                if (object.ReferenceEquals(newFollowing, oldFollowing))
                    return this;
            }

            var newDelegate = (MulticastDelegate) MemberwiseClone();
            newDelegate.following = newFollowing;
            return newDelegate;
        }

    }



    //
    // the following class is substituted instead of references to the artificial
    // delegates generated by DotNetImporter for java functional interfaces.
    //
    // application code uses an import library generated by DotNetImporter, and
    // creates a delegate for type someFunctionalInterface.Delegate.  the delegate
    // is only a placeholder type, so is translated to this class here.  see also:
    // DotNetImporter (BuildDelegate), Delegate module, and CodeCall module.
    //

    public sealed class FunctionalInterfaceDelegate : MulticastDelegate
    {
        public FunctionalInterfaceDelegate(object argTarget, object argInvokable)
            : base(argTarget, argInvokable)
        {
        }

        public object AsInterface() => invokable;
    }



    //
    //
    //

    public static class DelegateUtil
    {

        public static void CopyBoxed(object fromObj, object toObj)
        {
            // a method that takes generic parameters, and is specialized for
            // primitive types, can be assigned to a delegate that takes the
            // primitive types.  this is permitted by invokedynamic, which
            // will box parameters as necessary.  and in such a case, the
            // 'fromObj' parameter will be a java boxed primitive, e.g.
            // java.lang.Integer, which we need to assign to our own boxed
            // primitive, e.g. system.Int32
            //
            // invoked from GenericUtil.Copy()

            switch (fromObj)
            {
                case java.lang.Boolean boolBox:
                    ((system.Boolean) toObj).Set(boolBox.booleanValue() ? 1 : 0);
                    break;
                case java.lang.Byte byteBox:
                    ((system.SByte) toObj).Set(byteBox.byteValue());
                    break;
                case java.lang.Character charBox:
                    ((system.Char) toObj).Set(charBox.charValue());
                    break;
                case java.lang.Short shortBox:
                    ((system.Int16) toObj).Set(shortBox.shortValue());
                    break;
                case java.lang.Integer intBox:
                    ((system.Int32) toObj).Set(intBox.intValue());
                    break;
                case java.lang.Long longBox:
                    ((system.Int64) toObj).Set(longBox.longValue());
                    break;
                case java.lang.Float floatBox:
                    ((system.Single) toObj).Set(floatBox.floatValue());
                    break;
                case java.lang.Double doubleBox:
                    ((system.Double) toObj).Set(doubleBox.doubleValue());
                    break;
            }
        }



        public static object DelegateParameter(object arg, System.Type proxyType)
        {
            //
            // helper method for delegates with generic parameters, which
            // may need to be transformed into primitive types, before the
            // target method is invoked.
            //
            // 1.  the interface method takes java.lang.Object for generic
            // parameters;  callers will box primitive values as necessary.
            // (see CheckAndBoxArguments method in CodeCall module)
            //
            // 2.  the code generated for the Invoke methods calls this
            // helper method for each generic parameter.  if the parameter
            // is the boxed form of a primitive, it is re-boxed for java,
            // e.g. java.lang.Integer instead of our boxed system.Int32.
            //
            // 3.  if the target method signature specifies primitives,
            // the invokeinterface knows to unbox the java boxed values.
            // this is for interfaces created via invokedynamic,
            // see also the LoadFunction method in the Delegate module.
            //

            switch (arg)
            {
                case system.Boolean boolArg:
                    if (object.ReferenceEquals(proxyType, typeof(system.Boolean)))
                    {
                        arg = (boolArg.Get() != 0) ? java.lang.Boolean.TRUE
                                                   : java.lang.Boolean.FALSE;
                    }
                    break;

                case system.SByte byteArg:      // also system.Byte
                    if (    object.ReferenceEquals(proxyType, typeof(system.SByte))
                         || object.ReferenceEquals(proxyType, typeof(system.Byte)))
                    {
                        arg = java.lang.Byte.valueOf((sbyte) byteArg.Get());
                    }
                    break;

                case system.Char charArg:
                    if (object.ReferenceEquals(proxyType, typeof(system.Char)))
                        arg = java.lang.Character.valueOf((char) charArg.Get());
                    break;

                case system.Int16 shortArg:     // also system.UInt16
                    if (    object.ReferenceEquals(proxyType, typeof(system.Int16))
                         || object.ReferenceEquals(proxyType, typeof(system.UInt16)))
                    {
                        arg = java.lang.Short.valueOf((short) shortArg.Get());
                    }
                    break;

                case system.Int32 intArg:       // also system.UInt32
                    /*if (object.ReferenceEquals(proxyType, typeof(system.Boolean)))
                    {
                        arg = (intArg.Get() != 0) ? java.lang.Boolean.TRUE
                                                  : java.lang.Boolean.FALSE;
                    }
                    else*/if (    object.ReferenceEquals(proxyType, typeof(system.Int32))
                               || object.ReferenceEquals(proxyType, typeof(system.UInt32)))
                    {
                        arg = java.lang.Integer.valueOf(intArg.Get());
                    }
                    break;

                case system.Int64 longArg:      // also system.UInt64
                    if (    object.ReferenceEquals(proxyType, typeof(system.Int64))
                         || object.ReferenceEquals(proxyType, typeof(system.UInt64)))
                    {
                        arg = java.lang.Long.valueOf((long) longArg.Get());
                    }
                    break;

                case system.Single floatArg:
                    if (object.ReferenceEquals(proxyType, typeof(system.Single)))
                        arg = java.lang.Float.valueOf((float) floatArg.Get());
                    break;

                case system.Double doubleArg:
                    if (object.ReferenceEquals(proxyType, typeof(system.Double)))
                        arg = java.lang.Double.valueOf((double) doubleArg.Get());
                    break;

                case system.Enum enumArg:
                    if (proxyType.IsEnum && object.ReferenceEquals(proxyType, arg.GetType()))
                    {
                        var val = enumArg.GetLong();
                        var typ = ((system.RuntimeType) proxyType.GetEnumUnderlyingType())
                                                                 .JavaClassForArray();
                        if (typ == java.lang.Integer.TYPE)
                            arg = java.lang.Integer.valueOf((int) val);
                        else if (typ == java.lang.Short.TYPE)
                            arg = java.lang.Short.valueOf((short) val);
                        else if (typ == java.lang.Byte.TYPE)
                            arg = java.lang.Byte.valueOf((sbyte) val);
                        else if (typ == java.lang.Long.TYPE)
                            arg = java.lang.Long.valueOf(val);
                        else if (typ == java.lang.Character.TYPE)
                            arg = java.lang.Character.valueOf((char) val);
                        else if (typ == java.lang.Boolean.TYPE)
                            arg = java.lang.Boolean.valueOf(val != 0 ? true : false);
                    }
                    break;
            }

            return arg;
        }


        public static object DelegateReturnValue(object val, System.Type proxyType)
        {
            switch (val)
            {
                case java.lang.Boolean boolVal:
                    var vBool = boolVal.booleanValue() ? 1 : 0;
                    if (object.ReferenceEquals(proxyType, typeof(system.Boolean)))
                        val = system.Boolean.Box(vBool);
                    else if (proxyType.IsEnum)
                        val = system.Enum.Box((long) vBool, proxyType);
                    break;

                case java.lang.Byte byteVal:
                    var vByte = byteVal.byteValue();
                    if (object.ReferenceEquals(proxyType, typeof(system.SByte)))
                        val = system.SByte.Box(vByte);
                    else if (object.ReferenceEquals(proxyType, typeof(system.Byte)))
                        val = system.Byte.Box(vByte);
                    else if (proxyType.IsEnum)
                        val = system.Enum.Box((long) vByte, proxyType);
                    break;

                case java.lang.Character charVal:
                    var vChar = charVal.charValue();
                    if (object.ReferenceEquals(proxyType, typeof(system.Char)))
                        val = system.Char.Box(vChar);
                    else if (proxyType.IsEnum)
                        val = system.Enum.Box((long) vChar, proxyType);
                    break;

                case java.lang.Short shortVal:
                    var vShort = shortVal.shortValue();
                    if (object.ReferenceEquals(proxyType, typeof(system.Int16)))
                        val = system.Int16.Box(vShort);
                    else if (object.ReferenceEquals(proxyType, typeof(system.UInt16)))
                        val = system.UInt16.Box(vShort);
                    else if (proxyType.IsEnum)
                        val = system.Enum.Box((long) vShort, proxyType);
                    break;

                case java.lang.Integer intVal:
                    var vInt = intVal.intValue();
                    if (object.ReferenceEquals(proxyType, typeof(system.Int32)))
                        val = system.Int32.Box(vInt);
                    else if (object.ReferenceEquals(proxyType, typeof(system.UInt32)))
                        val = system.UInt32.Box(vInt);
                    else if (proxyType.IsEnum)
                        val = system.Enum.Box((long) vInt, proxyType);
                    break;

                case java.lang.Long longVal:
                    var vLong = longVal.longValue();
                    if (object.ReferenceEquals(proxyType, typeof(system.Int64)))
                        val = system.Int64.Box(vLong);
                    else if (object.ReferenceEquals(proxyType, typeof(system.UInt64)))
                        val = system.UInt64.Box(vLong);
                    else if (proxyType.IsEnum)
                        val = system.Enum.Box(vLong, proxyType);
                    break;

                case java.lang.Float floatVal:
                    if (object.ReferenceEquals(proxyType, typeof(system.Single)))
                        val = system.Single.Box(floatVal.floatValue());
                    break;

                case java.lang.Double doubleVal:
                    if (object.ReferenceEquals(proxyType, typeof(system.Double)))
                        val = system.Double.Box(doubleVal.doubleValue());
                    break;
            }

            return val;
        }



        public static bool DelegateReturnValueZ(object val) => (bool) (
            (val is java.lang.Boolean)   ? (((java.lang.Boolean) val).booleanValue())
                                         : (((system.Boolean) val).Get() != 0 ? true : false)
        );

        public static byte DelegateReturnValueB(object val) => (byte) (
             (val is java.lang.Byte)     ? (((java.lang.Byte) val).byteValue())
          :  (val is system.SByte)       ? (((system.SByte) val).Get())
                                         : (((system.Byte) val).Get())
        );

        public static char DelegateReturnValueC(object val) => (char) (
            (val is java.lang.Character) ? (((java.lang.Character) val).charValue())
                                         : (((system.Char) val).Get())
        );

        public static short DelegateReturnValueS(object val) => (short) (
             (val is java.lang.Short)    ? (((java.lang.Short) val).shortValue())
          :  (val is system.Int16)       ? (((system.Int16) val).Get())
                                         : (((system.UInt16) val).Get())
        );

        public static int DelegateReturnValueI(object val) => (int) (
             (val is java.lang.Integer)  ? (((java.lang.Integer) val).intValue())
          :  (val is system.Int32)       ? (((system.Int32) val).Get())
                                         : (((system.UInt32) val).Get())
        );

        public static long DelegateReturnValueJ(object val) => (long) (
             (val is java.lang.Long)     ? (((java.lang.Long) val).longValue())
          :  (val is system.Int64)       ? (((system.Int64) val).Get())
                                         : (((system.UInt64) val).Get())
        );

        public static float DelegateReturnValueF(object val) => (float) (
            (val is java.lang.Float)     ? (((java.lang.Float) val).floatValue())
                                         : (((system.Single) val).Get())
        );

        public static double DelegateReturnValueD(object val) => (double) (
            (val is java.lang.Double)    ? (((java.lang.Double) val).doubleValue())
                                         : (((system.Double) val).Get())
        );

    }

}
